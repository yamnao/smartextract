#' Function to extract the different component of a SMART Survey
#'
#' @details Function to extract information from a unique SMART Survey
#' @param name_file name of SMART Survey
#' @param smart_content SMART Survey content
#' @param admins_list obtained through the function f_location_possibility
#' @return [list] list containing the level of the SMART Survey, the date of the SMART and individual/aggregate
#' @export
f_extract_info_smart <- function(name_file, smart_content, admins_list){
  if(is_individual_survey(smart_content)){
    type_survey <- 'individual'
  }else{
    type_survey <- 'aggregate'
  }
  date <- find_date(name_file, smart_content)
  area <- find_stratum_level(name_file, smart_content, admins_list)
  ## name_admin1, level_admin, day, month, year, type_survey
  return(c(area, date, type_survey))
}

#' test if the survey is an individual or an aggregate one
#'
#' @param smart_content coontent of the SMART Survey
#' @return TRUE is the .as file is an individual one
is_individual_survey <- function(smart_content){
  pos <- grep("\\Mortality_new:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
  pos2 <- grep("\\Mor_individual:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
  if((pos2 - pos) != 1){
    return(FALSE)
  }else{
    return(TRUE)
  }
}

#' Find the date using .as information
#'
#' @param smart_content content of .as file
#' @return Date - Day, Month, Year
find_date <- function(name_file, smart_content){
  # First we want to extract the minimum date of the smart content
  # Most of the time the first line of the smart surveys content will give information on the type of date used
  output_date <- c()
  type_date <- unlist(strsplit(smart_content[1], split=""))
  if(length(type_date)!=0){
    grep_date <- smart_content[grep("/20", smart_content, ignore.cas=TRUE, useBytes = TRUE)]
    grep_date <- sapply(strsplit(grep_date, "\t"),"[[",1)
    if(length(grep_date) != 0){
      grep_date <- as.Date(grep_date, format = paste('%', type_date[1], '/%', type_date[2],
                                                     '/%', stringr::str_to_upper(type_date[3]), sep=""))
      output_date <- unlist(strsplit(as.character(min(grep_date)), '-'))
    }
  } # If there is no date in the content, we can use the title
  if(length(output_date) == 0){
    output_date <- as.numeric(unlist(regmatches(name_file, gregexpr("[[:digit:]]+", name_file))))
    if(length(output_date) == 0){
      output_date <- c('NA', 'NA', 'NA')
    }
    output_date <- c(output_date[1], output_date[2], '01')
  }
  return(output_date)
}

#' Extract file name information and where the location could be in the smart content
#'
#' @param name_file name of the file
#' @param smart_content content of the SMART
#' @return list of information
extract_location_smart <- function(name_file, smart_content){
  ## Extract the part of the survey where the initial name of the smart is saved
  pos <- grep("\\Planning:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
  pos2 <- grep("Cluster", smart_content, ignore.cas=TRUE)[2]
  #Concatenate those information with the one obtained in the file name
  information_names <- c(lapply(strsplit(stringr::str_split(name_file, stringr::fixed('.as'))[[1]], "_|/| "), tolower)[[1]],
                         lapply(strsplit(smart_content[(pos+1):(pos2-1)], "_|/| "), tolower)[[1]])
  information_names <- information_names[information_names!=""]
  return(information_names)
}

#' Find the stratum level using .as information and settlement.csv file
#'
#' @param name name of the .as file
#' @return Two elements -- type of level and the name of the settlement/district/region/lhz
find_stratum_level <- function(name_file, smart_content, admins_list){
  # First be sure we are comparing everything without punctuations and spaces
  admin_list <- admins_list |>
    dplyr::mutate(eventual_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", eventual_name)),
                  right_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", right_name)))
  # Then extract the infromation in the SMART Survey
  information_names <- extract_location_smart(name_file, smart_content)
  # If file name is empty or no information is available in the .as file
  if(length(information_names) == 0){
    return(c(NA, NA))
  }
  # Else we are going to compare all the different information and find the lowest admin level
  final_res <- c(NA, NA)
  for(elmt in information_names){
    ##if the name of the file corresponds to a settlement or a district
    if(elmt %in% admin_list$eventual_name_low){
      # if we already have access at the lowest admin level
      if(is.na(final_res[2])){
        final_res <- c(admin_list[which(elmt == admin_list$eventual_name_low), 'right_name'],
                       admin_list[which(elmt == admin_list$eventual_name_low), 'level'])
      }else if(final_res[2] != 'admin2'){
        final_res <- c(admin_list[which(elmt == admin_list$eventual_name_low), 'right_name'],
                       admin_list[which(elmt == admin_list$eventual_name_low), 'level'])
      }
    }else if(elmt %in% admin_list$right_name_low){
      if(length(final_res) == 0){
        final_res <- c(admin_list[which(elmt == admin_list$right_name_low), 'right_name'],
                 admin_list[which(elmt == admin_list$right_name_low), 'level'])
      }else if(final_res[2] != 'admin2'){
        final_res <- c(admin_list[which(elmt == admin_list$right_name_low), 'right_name'],
                       admin_list[which(elmt == admin_list$right_name_low), 'level'])
      }
    }
  }
  return(final_res)
}
