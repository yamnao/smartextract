library(smartextract)
library(smartextract)
library(smartextract)
library(smartextract)
smart_folder <- 'ext_data/smart_surveys/results/smart_with_issue/'
country_data <- NA
if(length(nrow(country_data)) != 0){
admins_list <- country_data
}else if(is.na(country_data)){
admins_list <- f_location_possibility(country)
}else{
admins_list <- NA
}
# List SMART Survey needed to be updated
files <- list.files(smart_folder, pattern='\\.as$')
file <- files[1]
# Extract the path of the file & its name
file_path <- paste(smart_folder, file, sep="")
name_file <- file
# Read the .as content
smart_content <- readLines(file_path)
View(smart_content)
# Extract info in the .as content
infos <- f_extract_info_smart(name_file, smart_content, admins_list)
infos
# Generate new name
new_name <- f_generate_new_name(log_file, country, infos)
new_name
# Extract nutrution, mortality and clusters infos
nutrition_data <- f_extract_nutrition_data(smart_content)
mortality_data <- f_extract_mortality_data(smart_content, infos[9])
clusters_data <- f_extract_clusters_data(smart_content)
# Extract metadata
metadata_data <- f_extract_metadata_data(smart_content)
#'Function to generate if there is an issue or not
#'
#' @param infos info of the smart surveys
#'
f_smart_is_issue <- function(infos){
date_survey <- ifelse(as.integer(infos[3]) > as.integer(format(Sys.Date(), "%Y")), yes = NA, no = infos[3])
if(is.na(infos[2]) & is.na(date_survey)){
issue = TRUE
type_issue = 'Unknown Date and Admin'
}else if(is.na(infos[2])){
issue = TRUE
type_issue = 'Unknown Admin'
}else if(is.na(date_survey)){
issue = TRUE
type_issue = 'Unknown Date'
}else{
issue = FALSE
type_issue = ""
}
return(c(issue, type_issue))
}
#' Function to extraction nutrition content of a SMART Survey
#'
#' @param log_file Log file
#' @param infos information extracted from the smart survey
#' @param nutrition_data nutrition data containing in the smart
#' @param mortality_data mortality data containing in the smart
#' @param clusters_data clusters data containing in the smart
#' @return [data.frame] return the log file updated
#' @export
f_update_log_file <- function(log_file, name_file, new_name,
infos, nutrition_data, mortality_data, clusters_data,
metadata_data){
#date_survey <- ifelse(as.integer(infos[3]) > as.integer(format(Sys.Date(), "%Y")), yes = NA, no = infos[3])
name_admin <- ifelse(infos[2] != 'admin2', yes = 'NA', no =infos[2])
issues <- f_smart_is_issue(infos)
issue <- issues[1]
type_issue <- issues[2]
access_nutrition <- ifelse(length(nutrition_data) == 0, yes = FALSE, no =TRUE)
access_mortality <- ifelse(length(mortality_data) == 0, yes = FALSE, no =TRUE)
access_clusters <- ifelse(length(clusters_data) == 0, yes = FALSE, no =TRUE)
data <- data.frame(old_name = name_file,
new_name=new_name,
time_smart_process = format(Sys.time(), "%a %b %d %X %Y"),
admin_level_survey = infos[2],
admin_name_survey = name_admin,
type_survey = infos[9],
min_year_survey = infos[5],
min_month_survey = infos[4],
min_day_survey = infos[3],
max_month_survey = infos[7],
max_year_survey = infos[8],
max_day_survey = infos[6],
is_issue = issue,
type_of_issue = type_issue,
access_nutrition = access_nutrition,
access_mortality = access_mortality,
access_clusters = access_clusters,
recall_days = metadata_data$recall_days,
inj_code = metadata_data$inj_code,
viol_code = metadata_data$viol_code,
unk_code = metadata_data$unk_code)
return(rbind(log_file, data))
}
#' Function to extraction nutrition content of a SMART Survey
#'
#' @param infos information extracted from the smart survey
#' @return new_name of the smart survey
#' @export
f_generate_new_name <- function(log_file, country, infos){
name <- paste(stringr::str_to_lower(country), '_',
infos[2], '_',
gsub("\u00a0", "", infos[1]), '_',
infos[3],
'_', infos[4], '_', 0, sep='')
# If a smart surveys as already the same name
if(length(log_file[['new_name']][grep(name, log_file[['new_name']])]) != 0){
number <- sapply(strsplit(log_file[['new_name']][grep(name, log_file[['new_name']])], "_"),"[[", 6)
name <- paste(stringr::str_to_lower(country), '_',
infos[2], '_',
gsub("\u00a0", "", infos[1]), '_',
infos[3],
'_', infos[4], '_', max(as.integer(number)) + 1, sep='')
}
return(name)
}
#' Function to create a issue folder in the output folder
#'
#' @param output_folder Folder where the results need to be saved
create_issue_folder <- function(output_folder){
check_and_generate_folder(paste(output_folder, '/smart_with_issue', sep=""))
}
#' Function to check if the folder exist and if not create it
check_and_generate_folder <- function(name){
if (file.exists(paste(name, sep='')) == FALSE){
dir.create(file.path(paste(name, sep='')),recursive = TRUE)
}
}
#' Function to generate log file
#'
#' @return [data.frame] log file
generate_log_file <- function(output_folder){
if(length(which(list.files(output_folder) == 'log_file.csv')) == 0){ ##if logfile doesnt exist
log_file <- data.frame()
}else{
log_file <- read.csv(paste(output_folder, '/log_file.csv', sep=""))
}
return(log_file)
}
#' Function to save the SMART Survey in the right folder (the one with the new name or the Issue one)
#'
#' @param output_folder output folder to save the smart content
#' @param log_file log file
#' @param new_name new name of the smart survey used to generate a new folder
#' @param nutrition_data nutrition data containing in the smart
#' @param mortality_data mortality data containing in the smart
#' @param clusters_data clusters data containing in the smart
#' @export
f_save_smart <- function(smart_folder, output_folder, file, new_name,
infos, nutrition_data, mortality_data, clusters_data,
metadata_data){
issues <- f_smart_is_issue(infos)
issue <- issues[1]
if(issue == TRUE){
file.copy(paste(smart_folder, file, sep = ""),
paste(output_folder, '/smart_with_issue', sep=""))
}else{
folder_name <- paste(output_folder, '/', new_name, sep="")
check_and_generate_folder(folder_name)
file.copy(paste(smart_folder, file, sep = ""),
folder_name)
write.table(nutrition_data, file = paste(folder_name, '/', new_name, '_nutrition_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
write.table(mortality_data, file = paste(folder_name,'/', new_name, '_mortality_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
write.table(clusters_data, file = paste(folder_name, '/', new_name, '_clusters_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
}
}
#' Function to return the right list of settlement depending of the country
#'
#' @details Settlement lists (admin1)
#' @param country Specified country of interest
#' @return [data.frame] DataFrame with all the possibility of admin1 to match SMART Surveys infos
#' @export
f_location_possibility <- function(country ='SOM'){
if(country == 'SOM'){
data <- smartextract::som_admins_options |>
dplyr::mutate(eventual_name = tolower(gsub("[[:punct:]]+", "", eventual_name)))
return(data)
}else if(country == 'KEN'){
data <- rio::import('data/ken_admins_options.rda') |>
dplyr::mutate(eventual_name = tolower(gsub("[[:punct:]]+", "", iconv(eventual_name,"WINDOWS-1252","UTF-8"))))
return(data)
}else{
return(c('Please specify a correct country'))
}
}
#' Function to add a name in the list of options to match the SMART Survey list
#' Save the output in the right rda
#'
#' @details Add something to the list
#' @param country Specified country of interest
#' @param list_to_add contains eventual name, right_name and level
#' @export
f_add_element_to_admins <- function(country, list_to_add){
if(country == 'SOM'){
som_admins_options <- rio::import(file = 'data/som_admins_options.rda')
som_admins_options <- rbind(list_to_add, som_admins_options)
save(som_admins_options, file = 'data/som_admins_options.rda')
}else if(country == 'KEN'){
ken_admins_options <- rio::import(file = 'data/ken_admins_options.rda')
ken_admins_options <- rbind(list_to_add, ken_admins_options)
save(ken_admins_options, file = 'data/ken_admins_options.rda')
}else{
return(c('Please specify a correct country'))
}
}
#' Function to extract the different component of a SMART Survey
#'
#' @details Function to extract information from a unique SMART Survey
#' @param name_file name of SMART Survey
#' @param smart_content SMART Survey content
#' @param admins_list obtained through the function f_location_possibility
#' @return [list] list containing: name_admin, level_admin, day/month/year min and max, type_survey.
#' @export
f_extract_info_smart <- function(name_file, smart_content, admins_list){
if(is_individual_survey(smart_content)){
type_survey <- 'individual'
}else{
type_survey <- 'aggregate'
}
date <- find_date(smart_content)
area <- find_stratum_level(name_file, smart_content, admins_list)
## name_admin1, level_admin, month, year, type_survey
return(c(area, date, type_survey))
}
#' test if the survey is an individual or an aggregate one
#'
#' @param smart_content coontent of the SMART Survey
#' @return TRUE is the .as file is an individual one
is_individual_survey <- function(smart_content){
pos <- grep("\\Mortality_new:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
pos2 <- grep("\\Mor_individual:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
if((pos2 - pos) != 1){
return(FALSE)
}else{
return(TRUE)
}
}
#' Find the date using .as information
#'
#' @param smart_content content of .as file
#' @return Date - Day, Month, Year
find_date <- function(smart_content){
# Extract the format of the data available at the beginning of the file
date_structure <- strsplit(smart_content[1], "")[[1]]
# Then extract the date in the file content
find_date <- smart_content[grep('/20', smart_content)]
date <- sapply(strsplit(find_date, "\t"),"[[",1)
if(length(date)==0){
#Case where we have small format for the year
find_date <- smart_content[grep('/1', smart_content)]
date <- sapply(strsplit(find_date, "\t"),"[[",1)
if(length(date) == 0){
return(c(NA, NA, NA, NA, NA, NA))
}
}
date <- as.Date(date, format = paste('%', date_structure[1],
'/%', date_structure[2],
'/%', date_structure[3], sep=""))
min_date <- min(date)
max_date <- max(date)
## Then find all the different date & extract the min of those date
return(c(lubridate::day(min_date),
lubridate::month(min_date), lubridate::year(min_date),
lubridate::day(max_date),
lubridate::month(max_date), lubridate::year(max_date)))
}
#' Extract file name information and where the location could be in the smart content
#'
#' @param name_file name of the file
#' @param smart_content content of the SMART
#' @return list of information
extract_location_smart <- function(name_file, smart_content){
## Extract the part of the survey where the initial name of the smart is saved
pos <- grep("\\Planning:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
pos2 <- grep("Cluster", smart_content, ignore.cas=TRUE)[2]
#Concatenate those information with the one obtained in the file name
information_names <- c(lapply(strsplit(stringr::str_split(name_file, stringr::fixed('.as'))[[1]], "_|/| "), tolower)[[1]],
lapply(strsplit(smart_content[(pos+1):(pos2-1)], "_|/| "), tolower)[[1]])
information_names <- information_names[information_names!=""]
return(information_names)
}
#' Find the stratum level using .as information and settlement.csv file
#'
#' @param name name of the .as file
#' @return Two elements -- type of level and the name of the settlement/district/region/lhz
find_stratum_level <- function(name_file, smart_content, admin_list){
#Case where we don't have a specific country
if(length(nrow(admin_list)) == 0){
return(c('unspecified', 'admin0'))
}
# First be sure we are comparing everything without punctuations and spaces
admin_list <- admin_list |>
dplyr::mutate(eventual_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", iconv(eventual_name,"WINDOWS-1252","UTF-8"))),
right_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", iconv(right_name,"WINDOWS-1252","UTF-8"))))
# Then extract the infromation in the SMART Survey
information_names <- extract_location_smart(name_file, smart_content)
# If file name is empty or no information is available in the .as file
if(length(information_names) == 0){
return(c(NA, NA))
}
# Else we are going to compare all the different information and find the lowest admin level
final_res <- c(NA, NA)
for(elmt in information_names){
##if the name of the file corresponds to a settlement or a district
if(elmt %in% admin_list$eventual_name_low){
# if we already have access at the lowest admin level
if(is.na(final_res[2])){
final_res <- c(admin_list[which(elmt == admin_list$eventual_name_low), 'right_name'],
admin_list[which(elmt == admin_list$eventual_name_low), 'level'])
}else if(final_res[2] != 'admin2'){
final_res <- c(admin_list[which(elmt == admin_list$eventual_name_low), 'right_name'],
admin_list[which(elmt == admin_list$eventual_name_low), 'level'])
}
}else if(elmt %in% admin_list$right_name_low){
if(is.na(final_res[2]) | final_res[2] != 'admin2'){
final_res <- c(admin_list[which(elmt == admin_list$right_name_low), 'right_name'],
admin_list[which(elmt == admin_list$right_name_low), 'level'])
}
}
}
return(final_res)
}
#' Function to extraction nutrition content of a SMART Survey
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] containing the nutrition information in the SMART
#' @export
f_extract_nutrition_data <- function(smart_content){
pos <- grep("SURVDATE\t", smart_content, ignore.cas=TRUE, useBytes = TRUE)
pos2 <- grep("\xa5Planning:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
data <- smart_content[(pos):(pos2-1)]
data<- strsplit(data, split = "\t")
data <- lapply(data, `length<-`, max(lengths(data)))
data <- as.data.frame(do.call(rbind, data))
colnames(data) <- data[1,]
data <- data[-1, ]
return(data)
}
#' Function to extraction mortality content of a SMART Survey
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] containing the mortality information in the SMART
#' @export
f_extract_mortality_data <- function(smart_content, type_survey){
if(type_survey == 'individual'){
pos <- grep("\\Mor_individual:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
pos2 <- grep("\\Mor_individual_options:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
data <- smart_content[(pos+1):(pos2-1)]
data<- strsplit(data, split = "\t")
data <- lapply(data, `length<-`, max(lengths(data)))
data <- as.data.frame(do.call(rbind, data))
data[is.na(data)] <- ""
colnames(data) <- data[1,]
data <- data[-1, ]
data <- data[rowSums(is.na(data)) != ncol(data), ]
return(data)
}else{
pos <- grep("\\Mortality_new:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
pos2 <- grep("\\Mor_individual:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
data <- smart_content[(pos+1):(pos2-1)]
data <- strsplit(data, split = "\t")
data <- lapply(data, `length<-`, max(lengths(data)))
data <- as.data.frame(do.call(rbind, data))
data[is.na(data)] <- ""
colnames(data) <- c('HH', 'Cluster',	'HH_members_Total', 'HH_members_u5', 'joined_HH_total',
'joined_HH_u5', 'left_HH_total', 'left_HH_u5', 'Births', 'Deaths_Total', 'Deaths_u5')
return(data)
}
}
#' Function to extraction mortality content of a SMART Survey
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] containing the clusters information in the SMART
#' @export
f_extract_clusters_data <- function(smart_content){
pos <- grep("Cluster", smart_content, ignore.cas=TRUE)[2]
pos2 <- grep("\\Training_new:", smart_content, ignore.cas=TRUE, useBytes = TRUE)
clusters_data <- smart_content[(pos+10):(pos2-1)]
clusters_data<- strsplit(clusters_data, split = "\t")
clusters_data <- lapply(clusters_data, `length<-`, max(lengths(clusters_data)))
clusters_data <- as.data.frame(do.call(rbind, clusters_data))
if(nrow(clusters_data) < 3){
return(data.frame())
}
colnames(clusters_data) <- c('settlements', 'pop', 'nb_cluster')
clusters_data <- dplyr::select(clusters_data, c('settlements', 'nb_cluster'))
clusters_data[which(clusters_data$nb_cluster == ""),]$nb_cluster <- NA
clusters_data <- tidyr::drop_na(clusters_data)
clusters_data$settlements <- tolower(clusters_data$settlements)
clusters_data$settlements <- stringr::str_replace_all(clusters_data$settlements , "[[:punct:]]", "")
clusters_data$settlements <- stringr::str_replace_all(clusters_data$settlements , "[[:space:]]", "")
clusters_data$settlements <- stringr::str_replace_all(clusters_data$settlements , "[[:digit:]]+", "")
return(clusters_data)
}
#' Function to extraction metadata content of a SMART Survey
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] containing the metadata information in the SMART
#' @export
f_extract_metadata_data <- function(smart_content){
#Recall days
recall_days <-f_extract_recall_day(smart_content)
##Code for injury/unknown or violent death
codes <- f_find_codes(smart_content)
metadata_data <- data.frame(recall_days = recall_days)
metadata_data$unk_code <- codes[1]
metadata_data$inj_code <- codes[2]
metadata_data$viol_code <- codes[3]
return(metadata_data)
}
#' Function to extraction recall day of a SMART Survey
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] containing the recall day in the SMART
f_extract_recall_day <- function(smart_content){
pos <- grep("Cluster", smart_content, ignore.cas=TRUE)[2]
return(strsplit(smart_content[pos+8], '\t')[[1]][1])
}
#' Find code to know the type of death if known
#'
#' @param smart_content Content of smart survey
#' @return [data.frame] 3 integers for three different types of death: unknow, injury and violence
f_find_codes <- function(smart_content){
pos <- grep('Mor_individual_options', smart_content, ignore.case=TRUE)
pos_unk <- grep('Unknown', smart_content, ignore.case = TRUE)
pos_inj <- grep('Injury', smart_content, ignore.case = TRUE)
pos_viol <- grep('Violence', smart_content, ignore.case = TRUE)
if(length(pos_unk) != 0){
score_unk <- pos_unk - pos
}else{
score_unk <- 0
}
if(length(pos_inj) != 0){
score_inj <- pos_inj - pos
}else{
score_inj <- 0
}
if(length(pos_viol) != 0){
score_viol <- pos_viol - pos
}else{
score_viol <- 0
}
return(c(score_unk, score_inj, score_viol))
}
#' Function to check the different issue files
#'
#' @param log_file log file
#' @param output_folder output_folder
#'
#' @export
f_deal_issues <- function(country, file, admin_name, log_file,
smart_folder, output_dir, country_data){
# First select the right country
# First option we are using a known country
if(length(nrow(country_data)) == 0){
admin_list <- f_location_possibility(country) |>
dplyr::mutate(eventual_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", eventual_name)),
right_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", right_name)))
}else{
admin_list <- country_data |>
dplyr::mutate(eventual_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", eventual_name)),
right_name_low = tolower(gsub("[[:punct:][:blank:]]+", "", right_name)))
}
# And check if the name is corresponding
if(admin_name %in% admin_list$right_name_low){
level <- admin_list[which(admin_name == admin_list$right_name_low), 'level'][1]
log_file[which(log_file$old_name == file), 'type_of_issue'] <- ""
log_file[which(log_file$old_name == file), 'issue'] <- FALSE
log_file[which(log_file$old_name == file), 'admin_level_survey'] <- level
log_file[which(log_file$old_name == file), 'admin_name_survey'] <- admin_name
infos <- c(log_file[which(log_file$old_name == file), 'admin_level_survey'][1],
log_file[which(log_file$old_name == file), 'admin_name_survey'][1],
log_file[which(log_file$old_name == file), 'year_survey'][1],
log_file[which(log_file$old_name == file), 'month_survey'][1])
log_file[which(log_file$old_name == file), 'new_name'] <- paste(stringr::str_to_lower(country), '_',
infos[1], '_',
gsub("\u00a0", "", infos[2]), '_',
infos[3],
'_', infos[4], '_', 0, sep='')
# Save the file and its content
file_path <- paste(smart_folder, file, sep="")
# Read the .as content
smart_content <- readLines(file_path)
# Extract nutrution, mortality and clusters infos
nutrition_data <- f_extract_nutrition_data(smart_content)
mortality_data <- f_extract_mortality_data(smart_content, log_file[which(log_file$old_name == file), 'type_survey'][1])
clusters_data <- f_extract_clusters_data(smart_content)
# Save the smart data
folder_name <- paste(output_dir, '/', log_file[which(log_file$old_name == file), 'new_name'][1], sep="")
smartextract::check_and_generate_folder(folder_name)
file.copy(paste(smart_folder, file, sep = ""),
folder_name)
write.table(nutrition_data, file = paste(folder_name, '/', log_file[which(log_file$old_name == file), 'new_name'][1], 'nutrition_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
write.table(mortality_data, file = paste(folder_name,'/', log_file[which(log_file$old_name == file), 'new_name'][1], 'mortality_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
write.table(clusters_data, file = paste(folder_name, '/', log_file[which(log_file$old_name == file), 'new_name'][1], 'clusters_data.csv', sep=""),
append = FALSE, sep=',', col.names=TRUE, row.names = FALSE)
unlink(paste(paste(output_dir, '/smart_with_issue/', sep=""), file, sep=""))
write.table(log_file, file = paste(output_dir, 'log_file.csv', sep=""), append=FALSE,
sep=',', col.names=TRUE, row.names = FALSE)
}
}
f_extract_metadata_data(smart_content)
infos
